//********************************************************
//   Do not modify this file directly.
//   This file is automatically generated via script.
//   Details can be found in docs/readonnxdefs.md .
//********************************************************

if (opName == "Abs")
   buildOperation<mlir::ONNXAbsOp>(node);
if (opName == "Acos")
   buildOperation<mlir::ONNXAcosOp>(node);
if (opName == "Acosh")
   buildOperation<mlir::ONNXAcoshOp>(node);
if (opName == "Add")
   buildOperation<mlir::ONNXAddOp>(node);
if (opName == "And")
   buildOperation<mlir::ONNXAndOp>(node);
if (opName == "ArgMax")
   buildOperation<mlir::ONNXArgMaxOp>(node);
if (opName == "ArgMin")
   buildOperation<mlir::ONNXArgMinOp>(node);
if (opName == "Asin")
   buildOperation<mlir::ONNXAsinOp>(node);
if (opName == "Asinh")
   buildOperation<mlir::ONNXAsinhOp>(node);
if (opName == "Atan")
   buildOperation<mlir::ONNXAtanOp>(node);
if (opName == "Atanh")
   buildOperation<mlir::ONNXAtanhOp>(node);
if (opName == "AveragePool")
   buildOperation<mlir::ONNXAveragePoolOp>(node);
if (opName == "BatchNormalization")
   ImportNodeBatchNormalization(node);
if (opName == "BitShift")
   buildOperation<mlir::ONNXBitShiftOp>(node);
if (opName == "Cast")
   buildOperation<mlir::ONNXCastOp>(node);
if (opName == "Ceil")
   buildOperation<mlir::ONNXCeilOp>(node);
if (opName == "Clip")
   buildOperation<mlir::ONNXClipOp>(node);
if (opName == "Compress")
   buildOperation<mlir::ONNXCompressOp>(node);
if (opName == "Concat")
   buildOperation<mlir::ONNXConcatOp>(node);
if (opName == "ConcatFromSequence")
   buildOperation<mlir::ONNXConcatFromSequenceOp>(node);
if (opName == "Constant")
   buildOperation<mlir::ONNXConstantOp>(node);
if (opName == "ConstantOfShape")
   buildOperation<mlir::ONNXConstantOfShapeOp>(node);
if (opName == "Conv")
   buildOperation<mlir::ONNXConvOp>(node);
if (opName == "ConvInteger")
   buildOperation<mlir::ONNXConvIntegerOp>(node);
if (opName == "ConvTranspose")
   buildOperation<mlir::ONNXConvTransposeOp>(node);
if (opName == "Cos")
   buildOperation<mlir::ONNXCosOp>(node);
if (opName == "Cosh")
   buildOperation<mlir::ONNXCoshOp>(node);
if (opName == "CumSum")
   buildOperation<mlir::ONNXCumSumOp>(node);
if (opName == "DepthToSpace")
   buildOperation<mlir::ONNXDepthToSpaceOp>(node);
if (opName == "DequantizeLinear")
   buildOperation<mlir::ONNXDequantizeLinearOp>(node);
if (opName == "Det")
   buildOperation<mlir::ONNXDetOp>(node);
if (opName == "Div")
   buildOperation<mlir::ONNXDivOp>(node);
if (opName == "Dropout")
   buildOperation<mlir::ONNXDropoutOp>(node);
if (opName == "DynamicQuantizeLinear")
   buildOperation<mlir::ONNXDynamicQuantizeLinearOp>(node);
if (opName == "Elu")
   buildOperation<mlir::ONNXEluOp>(node);
if (opName == "Equal")
   buildOperation<mlir::ONNXEqualOp>(node);
if (opName == "Erf")
   buildOperation<mlir::ONNXErfOp>(node);
if (opName == "Exp")
   buildOperation<mlir::ONNXExpOp>(node);
if (opName == "Expand")
   buildOperation<mlir::ONNXExpandOp>(node);
if (opName == "EyeLike")
   buildOperation<mlir::ONNXEyeLikeOp>(node);
if (opName == "Flatten")
   buildOperation<mlir::ONNXFlattenOp>(node);
if (opName == "Floor")
   buildOperation<mlir::ONNXFloorOp>(node);
if (opName == "GRU")
   buildOperation<mlir::ONNXGRUOp>(node);
if (opName == "Gather")
   buildOperation<mlir::ONNXGatherOp>(node);
if (opName == "GatherElements")
   buildOperation<mlir::ONNXGatherElementsOp>(node);
if (opName == "GatherND")
   buildOperation<mlir::ONNXGatherNDOp>(node);
if (opName == "Gemm")
   buildOperation<mlir::ONNXGemmOp>(node);
if (opName == "GlobalAveragePool")
   buildOperation<mlir::ONNXGlobalAveragePoolOp>(node);
if (opName == "GlobalLpPool")
   buildOperation<mlir::ONNXGlobalLpPoolOp>(node);
if (opName == "GlobalMaxPool")
   buildOperation<mlir::ONNXGlobalMaxPoolOp>(node);
if (opName == "Greater")
   buildOperation<mlir::ONNXGreaterOp>(node);
if (opName == "HardSigmoid")
   buildOperation<mlir::ONNXHardSigmoidOp>(node);
if (opName == "Hardmax")
   buildOperation<mlir::ONNXHardmaxOp>(node);
if (opName == "Identity")
   buildOperation<mlir::ONNXIdentityOp>(node);
if (opName == "If")
   buildOperation<mlir::ONNXIfOp>(node);
if (opName == "InstanceNormalization")
   buildOperation<mlir::ONNXInstanceNormalizationOp>(node);
if (opName == "IsInf")
   buildOperation<mlir::ONNXIsInfOp>(node);
if (opName == "IsNaN")
   buildOperation<mlir::ONNXIsNaNOp>(node);
if (opName == "LRN")
   buildOperation<mlir::ONNXLRNOp>(node);
if (opName == "LSTM")
   buildOperation<mlir::ONNXLSTMOp>(node);
if (opName == "LeakyRelu")
   buildOperation<mlir::ONNXLeakyReluOp>(node);
if (opName == "Less")
   buildOperation<mlir::ONNXLessOp>(node);
if (opName == "Log")
   buildOperation<mlir::ONNXLogOp>(node);
if (opName == "LogSoftmax")
   buildOperation<mlir::ONNXLogSoftmaxOp>(node);
if (opName == "Loop")
   buildOperation<mlir::ONNXLoopOp>(node);
if (opName == "LpNormalization")
   buildOperation<mlir::ONNXLpNormalizationOp>(node);
if (opName == "LpPool")
   buildOperation<mlir::ONNXLpPoolOp>(node);
if (opName == "MatMul")
   buildOperation<mlir::ONNXMatMulOp>(node);
if (opName == "MatMulInteger")
   buildOperation<mlir::ONNXMatMulIntegerOp>(node);
if (opName == "Max")
   buildOperation<mlir::ONNXMaxOp>(node);
if (opName == "MaxPool")
   ImportNodeMaxPool(node);
if (opName == "MaxRoiPool")
   buildOperation<mlir::ONNXMaxRoiPoolOp>(node);
if (opName == "MaxUnpool")
   buildOperation<mlir::ONNXMaxUnpoolOp>(node);
if (opName == "Mean")
   buildOperation<mlir::ONNXMeanOp>(node);
if (opName == "MeanVarianceNormalization")
   buildOperation<mlir::ONNXMeanVarianceNormalizationOp>(node);
if (opName == "Min")
   buildOperation<mlir::ONNXMinOp>(node);
if (opName == "Mod")
   buildOperation<mlir::ONNXModOp>(node);
if (opName == "Mul")
   buildOperation<mlir::ONNXMulOp>(node);
if (opName == "Multinomial")
   buildOperation<mlir::ONNXMultinomialOp>(node);
if (opName == "Neg")
   buildOperation<mlir::ONNXNegOp>(node);
if (opName == "NonMaxSuppression")
   buildOperation<mlir::ONNXNonMaxSuppressionOp>(node);
if (opName == "NonZero")
   buildOperation<mlir::ONNXNonZeroOp>(node);
if (opName == "Not")
   buildOperation<mlir::ONNXNotOp>(node);
if (opName == "OneHot")
   buildOperation<mlir::ONNXOneHotOp>(node);
if (opName == "Or")
   buildOperation<mlir::ONNXOrOp>(node);
if (opName == "PRelu")
   buildOperation<mlir::ONNXPReluOp>(node);
if (opName == "Pad")
   ImportNodePad(node);
if (opName == "Pow")
   buildOperation<mlir::ONNXPowOp>(node);
if (opName == "QLinearConv")
   buildOperation<mlir::ONNXQLinearConvOp>(node);
if (opName == "QLinearMatMul")
   buildOperation<mlir::ONNXQLinearMatMulOp>(node);
if (opName == "QuantizeLinear")
   buildOperation<mlir::ONNXQuantizeLinearOp>(node);
if (opName == "RNN")
   buildOperation<mlir::ONNXRNNOp>(node);
if (opName == "RandomNormal")
   buildOperation<mlir::ONNXRandomNormalOp>(node);
if (opName == "RandomNormalLike")
   buildOperation<mlir::ONNXRandomNormalLikeOp>(node);
if (opName == "RandomUniform")
   buildOperation<mlir::ONNXRandomUniformOp>(node);
if (opName == "RandomUniformLike")
   buildOperation<mlir::ONNXRandomUniformLikeOp>(node);
if (opName == "Range")
   buildOperation<mlir::ONNXRangeOp>(node);
if (opName == "Reciprocal")
   buildOperation<mlir::ONNXReciprocalOp>(node);
if (opName == "ReduceL1")
   buildOperation<mlir::ONNXReduceL1Op>(node);
if (opName == "ReduceL2")
   buildOperation<mlir::ONNXReduceL2Op>(node);
if (opName == "ReduceLogSum")
   buildOperation<mlir::ONNXReduceLogSumOp>(node);
if (opName == "ReduceLogSumExp")
   buildOperation<mlir::ONNXReduceLogSumExpOp>(node);
if (opName == "ReduceMax")
   buildOperation<mlir::ONNXReduceMaxOp>(node);
if (opName == "ReduceMean")
   buildOperation<mlir::ONNXReduceMeanOp>(node);
if (opName == "ReduceMin")
   buildOperation<mlir::ONNXReduceMinOp>(node);
if (opName == "ReduceProd")
   buildOperation<mlir::ONNXReduceProdOp>(node);
if (opName == "ReduceSum")
   buildOperation<mlir::ONNXReduceSumOp>(node);
if (opName == "ReduceSumSquare")
   buildOperation<mlir::ONNXReduceSumSquareOp>(node);
if (opName == "Relu")
   buildOperation<mlir::ONNXReluOp>(node);
if (opName == "Reshape")
   ImportNodeReshape(node);
if (opName == "Resize")
   buildOperation<mlir::ONNXResizeOp>(node);
if (opName == "ReverseSequence")
   buildOperation<mlir::ONNXReverseSequenceOp>(node);
if (opName == "RoiAlign")
   buildOperation<mlir::ONNXRoiAlignOp>(node);
if (opName == "Round")
   buildOperation<mlir::ONNXRoundOp>(node);
if (opName == "Scan")
   buildOperation<mlir::ONNXScanOp>(node);
if (opName == "Scatter")
   buildOperation<mlir::ONNXScatterOp>(node);
if (opName == "ScatterElements")
   buildOperation<mlir::ONNXScatterElementsOp>(node);
if (opName == "ScatterND")
   buildOperation<mlir::ONNXScatterNDOp>(node);
if (opName == "Selu")
   buildOperation<mlir::ONNXSeluOp>(node);
if (opName == "SequenceAt")
   buildOperation<mlir::ONNXSequenceAtOp>(node);
if (opName == "SequenceConstruct")
   buildOperation<mlir::ONNXSequenceConstructOp>(node);
if (opName == "SequenceEmpty")
   buildOperation<mlir::ONNXSequenceEmptyOp>(node);
if (opName == "SequenceErase")
   buildOperation<mlir::ONNXSequenceEraseOp>(node);
if (opName == "SequenceInsert")
   buildOperation<mlir::ONNXSequenceInsertOp>(node);
if (opName == "SequenceLength")
   buildOperation<mlir::ONNXSequenceLengthOp>(node);
if (opName == "Shape")
   buildOperation<mlir::ONNXShapeOp>(node);
if (opName == "Shrink")
   buildOperation<mlir::ONNXShrinkOp>(node);
if (opName == "Sigmoid")
   buildOperation<mlir::ONNXSigmoidOp>(node);
if (opName == "Sign")
   buildOperation<mlir::ONNXSignOp>(node);
if (opName == "Sin")
   buildOperation<mlir::ONNXSinOp>(node);
if (opName == "Sinh")
   buildOperation<mlir::ONNXSinhOp>(node);
if (opName == "Size")
   buildOperation<mlir::ONNXSizeOp>(node);
if (opName == "Slice")
   buildOperation<mlir::ONNXSliceOp>(node);
if (opName == "Softmax")
   buildOperation<mlir::ONNXSoftmaxOp>(node);
if (opName == "Softplus")
   buildOperation<mlir::ONNXSoftplusOp>(node);
if (opName == "Softsign")
   buildOperation<mlir::ONNXSoftsignOp>(node);
if (opName == "SpaceToDepth")
   buildOperation<mlir::ONNXSpaceToDepthOp>(node);
if (opName == "Split")
   buildOperation<mlir::ONNXSplitOp>(node);
if (opName == "SplitToSequence")
   buildOperation<mlir::ONNXSplitToSequenceOp>(node);
if (opName == "Sqrt")
   buildOperation<mlir::ONNXSqrtOp>(node);
if (opName == "Squeeze")
   buildOperation<mlir::ONNXSqueezeOp>(node);
if (opName == "StringNormalizer")
   buildOperation<mlir::ONNXStringNormalizerOp>(node);
if (opName == "Sub")
   buildOperation<mlir::ONNXSubOp>(node);
if (opName == "Sum")
   buildOperation<mlir::ONNXSumOp>(node);
if (opName == "Tan")
   buildOperation<mlir::ONNXTanOp>(node);
if (opName == "Tanh")
   buildOperation<mlir::ONNXTanhOp>(node);
if (opName == "TfIdfVectorizer")
   buildOperation<mlir::ONNXTfIdfVectorizerOp>(node);
if (opName == "ThresholdedRelu")
   buildOperation<mlir::ONNXThresholdedReluOp>(node);
if (opName == "Tile")
   buildOperation<mlir::ONNXTileOp>(node);
if (opName == "TopK")
   buildOperation<mlir::ONNXTopKOp>(node);
if (opName == "Transpose")
   buildOperation<mlir::ONNXTransposeOp>(node);
if (opName == "Unique")
   buildOperation<mlir::ONNXUniqueOp>(node);
if (opName == "Unsqueeze")
   buildOperation<mlir::ONNXUnsqueezeOp>(node);
if (opName == "Upsample")
   buildOperation<mlir::ONNXUpsampleOp>(node);
if (opName == "Where")
   buildOperation<mlir::ONNXWhereOp>(node);
if (opName == "Xor")
   buildOperation<mlir::ONNXXorOp>(node);
