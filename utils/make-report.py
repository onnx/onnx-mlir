#!/usr/bin/python3

# SPDX-License-Identifier: Apache-2.0

##################### make-report.py ########################################
#
# Copyright 2023 The IBM Research Authors.
#
################################################################################
#
# This file scan -onnx-op-report=* and process it
#
# For patterns, see src/Conversion/ONNXToKrnl/ONNXToKrnlCommon.cpp, 
# impl::onnxToKrnlParallelReport(...) and impl::onnxToKrnlSimdReport(...)
#
################################################################################

import sys
import os
import getopt
import fileinput
import re
import subprocess

def print_usage(msg = ""):
    if msg:
        print("Error:", msg, "\n")
    print("make-report -[hs] -i <file_log> [-d <num>] [-p <op regexp>]")
    print("")
    print("Usage: scan onnx op report generated by `onnx-mlir1 with `--onnx-op-report`")
    print("equal to `Simd` or `Parallel` and report statistics about the ops found")
    print("in the provided input log.")
    print("")
    print("Parameters:")
    print("  -d/--detail <num>:     Print statistics:")
    print("                         0: Just count successful/unsuccessful ops.")
    print("                         1: Also count reasons for success/failure.")
    print("                         2: Also list metrics.")
    print("                         3: Also list node name.")
    print("  -h/--help:             Print usage.")
    print("  -i/--input <file_log>: Input file to be scanned.")
    print("  -p/--pattern <regexp>: Focus only on ops that match the regexp pattern.")
    print("  -s/supported:          Focus only on ops that are supported, i.e. skip unsupported ops.")
    print("")
    print("More info:")
    print("  If you need more specific info on individual success/failure, run ")
    print("  `onnx-mlir --debug-only=lowering-to-krnl` and look at the compiler output.")
    print("  Use `-d 3` to correlate the node name printed here with compiler output.")
    print("")
    exit(1)

################################################################################
# Global info.

report_pattern_count = {}
report_level_pattern_count = {}
# ==ONNX-SIMD-REPORT==, op name, node name, info
simd_report_str = r'^==ONNX-SIMD-REPORT==,\s*([0-9a-zA-Z\.\-]+)\s*,([^,]*),(.*)'
simd_stat_message = "SIMD vector length (in elements), SIMD loop trip count (-1 is runtime), message"
report_str = simd_report_str
stat_message = simd_stat_message
focus_on_op_with_pattern = r'.*'
supported_only = False
report_level = 0 # 0: none; 1: details; 2: extra info; 3: plus node names

################################################################################
# Support.

def record_pattern(pat, det):
    global report_pattern_count, report_level_pattern_count
    global report_level

    if pat in report_pattern_count:
        report_pattern_count[pat] = report_pattern_count[pat] + 1
        if report_level > 0:
            det_dict = report_level_pattern_count[pat]
            if det in det_dict:
                det_dict[det] = det_dict[det] + 1
            else:
                det_dict[det] = 1
            report_level_pattern_count[pat] = det_dict
    else:
        report_pattern_count[pat] = 1
        if report_level > 0:
            det_dict = {}
            det_dict[det] = 1
            report_level_pattern_count[pat] = det_dict

################################################################################
# Main.

def parse_file(file_name):
    global report_str, report_level, focus_on_op_with_pattern, supported_only

    try:
        file = open(file_name, 'r')
    except OSError:
        print_usage("Could not open file `"+file_name+"`")

    for line in file:
        l = line.rstrip()
        # Scan pattern, only keep at it only if we have the report info.
        p = re.match(report_str, l)
        if p is None:
            continue
        # Have a line.
        op = p[1]
        node_name = p[2]
        details = p[3]
        if supported_only and re.search(r'unsupported', details) is not None:
            # Has an op that is unsupported, and we asked to skip them
            continue
        f = re.match(focus_on_op_with_pattern, op)
        if f is None:
            continue
        # Have an interesting op.
        if report_level == 0:
            record_pattern(op, "")
        if report_level == 1:
            detail_array = details.split(",")
            record_pattern(op, detail_array[-1])
        elif report_level == 2:
            record_pattern(op, details)
        elif report_level == 3:
            record_pattern(op, node_name + ", " + details)

def make_report():
    global report_pattern_count, report_level_pattern_count
    global report_level, supported_only, stat_message

    if (report_level > 1):
        print("Statistic legend:")
        if (report_level == 2):
            print("   num:", stat_message, "\n")
        elif (report_level == 3):
            print("   num: node-name, ", stat_message, "\n")
        print("")
    if supported_only:
        print("Statistics (ignore unsupported ops):")
    else:
        print("Statistics (all ops):")
    for key in sorted(report_pattern_count):
        print("  ", key, ":", report_pattern_count[key])
        if report_level:
            det_dict = report_level_pattern_count[key]
            for det_key in sorted(det_dict):
                if det_dict[det_key] == report_pattern_count[key]:
                    print("     *:", det_key)
                else:
                    print("    ", det_dict[det_key], ":", det_key)


def main(argv):
    global report_level, focus_on_op_with_pattern, supported_only

    file_name = ""
    try:
        opts, args = getopt.getopt(
            argv, "d:fhi:p:s", ["detail=", "full", "help", "input=", "pattern=", "supported"])
    except getopt.GetoptError:
        print_usage("Failure to parse inputs")
    for opt, arg in opts:
        if opt in ('-d', "--details"):
            report_level = int(arg)
            if (report_level<0 or report_level > 3):
                print_usage("detail level is 0, 1, 2, or 3")
        elif opt in ('-h', "--help"):
            print_usage()
        elif opt in ('-i', "--input"):
            file_name = arg
        elif opt in ('-p', "--pattern"):
            focus_on_op_with_pattern = arg
            if report_level == 0:
                report_level = 1
        elif opt in ('-s', "--supported"):
            supported_only = True

    if not file_name:
        print_usage("Command requires an input file name.\n")

    parse_file(file_name)
    make_report()

if __name__ == "__main__":
    main(sys.argv[1:])
